{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"metagf library Python implementation of numerical routines for computation of Sommerfeld integrals momi - implements DE tanh-sinh integration routines and general weighted averages as defined by Michalski&Mosig 1 intde - implements double exponential-type quadrature formulas from Golubovic et al 2 sommerfeld - sommerfeld integrals by Alvarez-Melcon 3 and Stevanovic 4 toms468 - optimal extensions of the 3-point gauss formula 5 Krzysztof A. Michalski and Juan R. Mosig. Efficient computation of sommerfeld integral tails methods and algorithms. Journal of Electromagnetic Waves and Applications , 30(3):281\u2013317, 2016. URL: https://www.ingentaconnect.com/content/tandf/jew/2016/00000030/00000003/art00001 , doi:doi:10.1080/09205071.2015.1129915 . \u21a9 Ru\u017eica Golubovi\u0107 Ni\u0107iforovi\u0107, Athanasios G. Polimeridis, and Juan R. Mosig. Fast computation of sommerfeld integral tails via direct integration based on double exponential-type quadrature formulas. IEEE Transactions on Antennas and Propagation , 59(2):694\u2013699, Feb 2011. doi:10.1109/TAP.2010.2096187 . \u21a9 Alejandro \u00c1lvarez Melc\u00f3n. Applications of the integral equation technique to the analysis and synthesis of multilayered printed shielded microwave circuits and cavity backed antennas . PhD thesis, EPFL, Lausanne, 1998. URL: http://infoscience.epfl.ch/record/32378 , doi:10.5075/epfl-thesis-1901 . \u21a9 Ivica Stevanovi\u0107. Modeling challenges in computational electromagnetics large planar multilayered structures and finite-thickness irises . PhD thesis, EPFL, Lausanne, 2005. URL: http://infoscience.epfl.ch/record/33680 , doi:10.5075/epfl-thesis-3212 . \u21a9 Thomas NL Patterson. The optimum addition of points to quadrature formulae. Mathematics of Computation , 22(104):847\u2013856, 1968. \u21a9","title":"metagf library"},{"location":"#metagf-library","text":"Python implementation of numerical routines for computation of Sommerfeld integrals momi - implements DE tanh-sinh integration routines and general weighted averages as defined by Michalski&Mosig 1 intde - implements double exponential-type quadrature formulas from Golubovic et al 2 sommerfeld - sommerfeld integrals by Alvarez-Melcon 3 and Stevanovic 4 toms468 - optimal extensions of the 3-point gauss formula 5 Krzysztof A. Michalski and Juan R. Mosig. Efficient computation of sommerfeld integral tails methods and algorithms. Journal of Electromagnetic Waves and Applications , 30(3):281\u2013317, 2016. URL: https://www.ingentaconnect.com/content/tandf/jew/2016/00000030/00000003/art00001 , doi:doi:10.1080/09205071.2015.1129915 . \u21a9 Ru\u017eica Golubovi\u0107 Ni\u0107iforovi\u0107, Athanasios G. Polimeridis, and Juan R. Mosig. Fast computation of sommerfeld integral tails via direct integration based on double exponential-type quadrature formulas. IEEE Transactions on Antennas and Propagation , 59(2):694\u2013699, Feb 2011. doi:10.1109/TAP.2010.2096187 . \u21a9 Alejandro \u00c1lvarez Melc\u00f3n. Applications of the integral equation technique to the analysis and synthesis of multilayered printed shielded microwave circuits and cavity backed antennas . PhD thesis, EPFL, Lausanne, 1998. URL: http://infoscience.epfl.ch/record/32378 , doi:10.5075/epfl-thesis-1901 . \u21a9 Ivica Stevanovi\u0107. Modeling challenges in computational electromagnetics large planar multilayered structures and finite-thickness irises . PhD thesis, EPFL, Lausanne, 2005. URL: http://infoscience.epfl.ch/record/33680 , doi:10.5075/epfl-thesis-3212 . \u21a9 Thomas NL Patterson. The optimum addition of points to quadrature formulae. Mathematics of Computation , 22(104):847\u2013856, 1968. \u21a9","title":"metagf library"},{"location":"demo/","text":"Example of math \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"Demo"},{"location":"demo/#example-of-math","text":"\\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"Example of math"},{"location":"refs/","text":"Bibliography Krzysztof A. Michalski and Juan R. Mosig. Efficient computation of sommerfeld integral tails methods and algorithms. Journal of Electromagnetic Waves and Applications , 30(3):281\u2013317, 2016. URL: https://www.ingentaconnect.com/content/tandf/jew/2016/00000030/00000003/art00001 , doi:doi:10.1080/09205071.2015.1129915 . \u21a9 Ru\u017eica Golubovi\u0107 Ni\u0107iforovi\u0107, Athanasios G. Polimeridis, and Juan R. Mosig. Fast computation of sommerfeld integral tails via direct integration based on double exponential-type quadrature formulas. IEEE Transactions on Antennas and Propagation , 59(2):694\u2013699, Feb 2011. doi:10.1109/TAP.2010.2096187 . \u21a9 Alejandro \u00c1lvarez Melc\u00f3n. Applications of the integral equation technique to the analysis and synthesis of multilayered printed shielded microwave circuits and cavity backed antennas . PhD thesis, EPFL, Lausanne, 1998. URL: http://infoscience.epfl.ch/record/32378 , doi:10.5075/epfl-thesis-1901 . \u21a9 Ivica Stevanovi\u0107. Modeling challenges in computational electromagnetics large planar multilayered structures and finite-thickness irises . PhD thesis, EPFL, Lausanne, 2005. URL: http://infoscience.epfl.ch/record/33680 , doi:10.5075/epfl-thesis-3212 . \u21a9 Thomas NL Patterson. The optimum addition of points to quadrature formulae. Mathematics of Computation , 22(104):847\u2013856, 1968. \u21a9","title":"Bibliography"},{"location":"refs/#bibliography","text":"Krzysztof A. Michalski and Juan R. Mosig. Efficient computation of sommerfeld integral tails methods and algorithms. Journal of Electromagnetic Waves and Applications , 30(3):281\u2013317, 2016. URL: https://www.ingentaconnect.com/content/tandf/jew/2016/00000030/00000003/art00001 , doi:doi:10.1080/09205071.2015.1129915 . \u21a9 Ru\u017eica Golubovi\u0107 Ni\u0107iforovi\u0107, Athanasios G. Polimeridis, and Juan R. Mosig. Fast computation of sommerfeld integral tails via direct integration based on double exponential-type quadrature formulas. IEEE Transactions on Antennas and Propagation , 59(2):694\u2013699, Feb 2011. doi:10.1109/TAP.2010.2096187 . \u21a9 Alejandro \u00c1lvarez Melc\u00f3n. Applications of the integral equation technique to the analysis and synthesis of multilayered printed shielded microwave circuits and cavity backed antennas . PhD thesis, EPFL, Lausanne, 1998. URL: http://infoscience.epfl.ch/record/32378 , doi:10.5075/epfl-thesis-1901 . \u21a9 Ivica Stevanovi\u0107. Modeling challenges in computational electromagnetics large planar multilayered structures and finite-thickness irises . PhD thesis, EPFL, Lausanne, 2005. URL: http://infoscience.epfl.ch/record/33680 , doi:10.5075/epfl-thesis-3212 . \u21a9 Thomas NL Patterson. The optimum addition of points to quadrature formulae. Mathematics of Computation , 22(104):847\u2013856, 1968. \u21a9","title":"Bibliography"},{"location":"reference/metagf/__init__/","text":"Numerical Sommerfeld Integrals intde Created on Tue Nov 12 14:35:35 2019 @author: U80824876 intdei ( G , a , rho , n , h , nu , args = ()) function A Python function or method used to integrate. If G takes many arguments, it is integrated along the axis corresponding to the first argument. double Lower limit of integration double Spatial variable integer Number of integration points in the quadrature rule double Step size parameter, default h = 1.0/32.0 integer Order of transformation nu = 0, 1 tuple, optional Extra arguments to pass to G float Numerical value of the integral G(kro, args) * J_nu(kro * rho) * kro^(nu+1) over the semi-infinite interval kro = (a, infty) intdei(G, a, n, args) This subroutine computes the integral of the following function G(kro, args) * J0(kro * rho) * kro, for nu = 0 G(kro, args) * J1(kro * rho) * kro^2, for nu = 1 over the inverval kro = (a, infty) using double exponential-type quadrature formulas from [1] Golubovic et al. \"Fast Computation of Sommerfeld Integral Tails via Direct Integration Based on Double Exponential-Type Quadrature Formulas,\" IEEE Transactions on Antennas and Propagation, vol. 59, no. 2, February 2011 Parameters Returns Rev Date Author Description v1 12NOV19 Ivica Stevanovic, OFCOM First implementation in python momi Created on Sat Oct 12 16:09:09 2019 This library of functions implements DE tanh-sinh integration routines and general weighted averages as defined in the following paper: Krzysztof A. Michalski & Juan R. Mosig (2016) Efficient computation of Sommerfeld integral tails \u2013 methods and algorithms, Journal of Electromagnetic Waves and Applications, 30:3, 281-317 https://doi.org/10.1080/09205071.2015.1129915 @author: Ivica Stevanovic (OFCOM) MosigMichalski ( mu , k , s , omega , X , R ) This function implements the weighted averages method via the Mosig-Michalski algorithm according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 mu: convergence (1 - logarithmic, 2 - otherwise) k: instantaneous transformation order (k = 0,...,kmax) s: kth partial sum omega: ratio of the current and previous remainder estimates at the transformation order k X: an array of dimension k+1: xn = beta + n, beta usually set to 1 R: an array of dimension k+1: containing remainders mixedQuad ( G , args , a , eps , maxlev ) This function computes the integral of function G over a semi-infinite interval [a, infty) using an automatic mixed quadrature rule according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral eps: square root of the desired precision maxlev: order of the tanh-sinh integration omega ( k , q , z , alpha , X ) This function computes the ratio of the current and previous remainder estimates at the transformation order k in Mosig-Michalski algorithm 7 according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 k: instantaneous transformation order (k = 0,...,kmax) q: equidistant spacing z: source-observer distance in z-direction alpha: 0.5-nu, where nu is the order of Bessel function in the integrand X: equidistant points (in rho) partExtrap ( G , rho , z , a , nu , eps , kmax , maxlev , args ) This function computes the integral of function G over a semi-infinite interval [a, infty) using a general partition-extrapolation algorithm via MosigMichalski according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral nu: order of Bessel function in the integrand eps: square root of the desired precision kmax: max order of the general WA algorithm maxlev: max level in DE tanh-sinh numerical integration partSum ( G , args , eh , e2h , n , eta , sigma , a , b ) Function computing higher level partial sum according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated eh: exponent of h (initial mesh size) e2h: exponent of 2h (initial mesh size) eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval tanhSinhQuad ( G , args , a , b , eps , maxlev ) This function computes the integral of function G over a bounded interval [a, b] using an automatic tanh-sinh quadrature rule according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral b: upper limit of the bounded integral eps: square root of the desired precision maxlev: order of the tanh-sinh integration Function G(kro) should be programmed as a two-parameter procedure G(c, d), where kro = c + d, c = a or b, and d = \u00b1\u03c3 \u03b4 , so that the singular part may be computed using d directly. For example, if the integrand comprises a term (kro\u2212a)^(-alpha) (b-kro)^(-beta) with alpha > 0 and beta > 0, this procedure should compute it as compute it as d^(-alpha) * (b-kro)^(-beta) when d > 0 and as (kro - a)^(-alpha) * (-d)^(-beta) when d < 0 term ( G , args , ekh , eta , sigma , a , b ) kth term of quadrature rule according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated ekh: exponent of the kth term exp(kh) eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval truncIndex ( G , args , eh , s , eta , sigma , a , b , nmax , kappa ) Function computing an initial truncation index and partial sum according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated eh: exponent of h (initial mesh size) s: initial value of the partial sum eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval nmax: maximum number of points in the term quadrature rule kappa: truncation error sommerfeld gauleg ( n , a1 , a2 ) gauleg: Gauss-Legendre n-point quadrature w, x = gauleg(n, a1, a2) where: Units, Definition Limits n: - Number of integration points >1 a1: - Lower limit of the integration a2: - Upper limit of the integration w: - Vector of weights x: - Vector of abscissae This subroutine computes the weights and abcissae for a Gauss- Legendre n-point quadrature formula. The program computes the n-roots of the Legendre polynomial of order n. It uses a Newton method to find numerically the zeros. Rev Date Author Description v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine halfsine ( func , a , c , nints , args ) function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float width of the half-sine contour float maximum height of the half-sine contour integer number of integration points tuple, optional Extra arguments to pass to func float The value of the integral half_sine: computes the integral of the function func(x,args) over a half-sine contour defined by the widht a and height c using Gauss-Legendre quadrature with required number of integration points nints y = half_sine(func, a, c, nints, args) Parameters Returns Rev Date Author Description v1 14NOV19 Ivica Stevanovic, OFCOM First implementation intt2_s0 ( G , rn , nt , a , b , args ) computes the integral of the following function J0(x r) x*G(x) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) integer Number of points in Gauss-Legendre integration float Lower integration limit float Upper integration limit tuple, optional Extra arguments to pass to G float The value of integral in the zero order Sommerfeld transformation over a bounded interval (a, b) in the bounded interval (a,b), where G(x, args) is spectral domain function and J0(x) is Bessel function of zero order and first kind y = intt2_s0(G, rn, nt, a, b, args) Parameters Returns Rev Date Author Description v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine intt2_s1 ( G , rn , nt , a , b , args ) computes the integral of the following function J1(x r) x^2 G(x, args) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) integer Number of points in Gauss-Legendre integration float Lower integration limit float Upper integration limit tuple, optional Extra arguments to pass to G float The value of integral in the zero order Sommerfeld transformation over a bounded interval (a, b) in the bounded interval (a,b), where G(x,*args) is spectral domain function and J1(x) is Bessel function of first order and first kind y = intt2_s1(G, arg, rn, nt, a, b) Parameters Returns Rev Date Author Description v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python it1_s0 ( G , rn , b1 , b2 , nt1 , args ) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Smaller semi-axis of the elliptic path float Larger axis of the elliptic path float Number of integration points tuple, optional Extra arguments to pass to G float The value of integral T1 (0,b1) in the zero order Sommerfeld transformation along the elliptic contour it1_s0: computes the integral T1 (0,b1) for the evaluation of zero order Sommerfeld transformation. The integral is computed following an elliptic contour path y = it1_s0(G, rn, b1, b2, nt1, args) Parameters Returns Rev Date Author Description v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine it1_s1 ( G , rn , b1 , b2 , nt1 , args ) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Smaller semi-axis of the elliptic path float Larger axis of the elliptic path float Number of integration points tuple, optional Extra arguments to pass to G float The value of integral T1 (0,b1) in the first order Sommerfeld transformation along the elliptic contour it1_s1: computes the integral T1 (0,b1) for the evaluation of first order Sommerfeld transformation. The integral is computed following an elliptic contour path y = it1_s1(G, rn, b1, b2, nt1) Parameters Returns Rev Date Author Description v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine it2_s0 ( G , rn , b2 , nt2 , y1 , cs , prec , nit , args ) computes the integral T2 (b2-infty) for the evaluation of zero order Sommerfeld transformation The integral is computed using the weighted averages method function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Starting point of the integration path (corresponds to the larger ellipse axis) integer Number of integration points per segment complex Value of the integral along the ellipse integer cs = 1 when source and obesrver are at the same z-coordinate float Required precision in the WA algorithm integer Maximum number of iterations tuple, optional Extra arguments to pass to G float The value of integral T2 (b2, infty) in the zero order Sommerfeld transformation using weigthed averages y = it2_s0(G, arg, rn, b2, nt2, y1, cs, prec) Parameters Returns Rev Date Author Description v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine it2_s1 ( G , rn , b2 , nt2 , y1 , cs , prec , nit , args ) computes the integral T2 (b2-infty) for the evaluation of first order Sommerfeld transformation The integral is computed using the weighted averages method function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Starting point of the integration path (corresponds to the larger ellipse axis) integer Number of integration points per segment complex Value of the integral along the ellipse integer cs = 1 when source and obesrver are at the same z-coordinate float Required precision in the WA algorithm integer Maximum number of iterations tuple, optional Extra arguments to pass to G float The value of integral T2 (b2, infty) in the first order Sommerfeld transformation using weigthed averages y = it2_s1(G, rn, b2, nt2, y1, cs, prec) Parameters Returns Rev Date Author Description v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine quad ( func , a , b , nints , args ) function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float lower limit of the integration interval float upper limit of the integration interval integer number of integration points tuple, optional Extra arguments to pass to func float The value of the integral quad: computes the integral of the function func(x,args) over real-axis x using Gauss-Legendre quadrature with required number of integration points nints over interval (a,b) y = quad(func, a, b, nints, args) Parameters Returns Rev Date Author Description v1 14NOV19 Ivica Stevanovic, OFCOM First implementation toms468 halfsine ( func , a , c , epsil , args ) function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float width of the half-sine contour float maximum height of the half-sine contour float required precision in Patterson quadrature tuple, optional Extra arguments to pass to func float The value of the integral integer Number integrand evaluations. float The projected relative error achieved by Patterson quadrature integer On exit normally icheck = 0. However, if convergence to the accuracy requested is not achieved, icheck = 1 on exit. half_sine: computes the integral of the function func(x,args) over a half-sine contour defined by the widht a and height c using Patterson quadrature with required precision epsil y, npts, relerr, icheck = half_sine(func, a, c, epsil, args) Parameters Returns Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation isign ( a , b ) Function isign(a, b) returns the value of a with the sign of b. Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python qsub ( f , a , b , epsil , args = ()) qsub This function routine performs automatic integration over a finite interval using the basic integration algorithm quad, together with, if necessary, a non- adaptive subdivision process. The call takes the form qqsub, npts, relerr, icheck = qsub(f, a, b epsil, args) and causes f(x,args) to be integrated over x in (a,b) with relative error hopefully not exceeding epsil. Should quad converge (icheck=0) then qsub will return the value obtained by it; otherwise subdivision will be invoked as a rescue operation in a non-adaptive manner. The argument relerr gives a crude estimate of the actual relative error obtained. The subdivision strategy is as follows: Let the interval (a,b) be divided into 2**n panels at step n of the subdivision process. quad is applied first to the subdivided interval on which quad last failed to converge, and if convergence is now achieved the remaining panels are integrated. should a convergence failure occur on any panel, the integration at that point is terminated and the procedure repeated with n increased by 1. The strategy ensures that possibly delinquent intervals are examined before work, which later might have to be discarded, is invested in well-behaved panels. The process is complete when no convergence failure occurs on any panel and the sum of the results obtained by quad on each panel is taken as the value of the integral. The process is very cautious in that the subdivision of the interval (a,b) is uniform, the fineness of which is controlled by the success of quad. In this way, it is rather difficult for a spurious convergence to slip through. The convergence criterion of quad is slightly relaxed in that a panel is deemed to have been successfully integrated if either quad converges or the estimated absolute error committed on this panel does not exceed epsil times the estimated absolute value of the integral over (a,b). This relaxation is to try to take account of a common situation where one particular panel causes special difficulty, perhaps due to singularity of some type. In this case, quad could obtain nearly exact answers on all other panels, and so the relative error for the total integration would be almost entirely due to the delinquent panel. Without this condition, the computation might continue despite the requested relative error being achieved. The outcome of the integration is indicated by icheck. icheck = 0 - convergence obtained without invoking subdivision. This corresponds to the direct use of quad. icheck = 1 - result obtained after invoking subdivision. icheck = 2 - as for icheck=1 but at some point the relaxed convergence criterion was used. the risk of underestimating the relative error will be increased. If necessary, confidence may be restored by checking epsil and relerr for a serious discrepancy. icheck negative if during the subdivision process the allowed upper limit on the number of panels that may be generated (presently 4096) is reached, a result is obtained which may be unreliable by continuing the integration without further subdivision ignoring convergence failures. This occurrence is flagged by returning icheck with negative sign. The reliability of the algorithm will decrease for large values of epsil. It is recommended that epsil should generally be less than about 0.001. Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine qsuba ( f , a , b , epsil , args = ()) qsuba This function routine performs automatic integration over a finite interval using the basic integration algorithm quad, together with, if necessary, an adaptive subdivision process. It is generally more efficient than the non-adaptive algorithm qsub but is likely to be less reliable (see Comp.J., 14, 189, 1971 ). The call takes the form result, npts, relerr, icheck = qsuba(f, a, b, epsil, arg) and causes f(x, arg) to be integrated over x in (a,b) with relative error hopefully not exceeding epsil. sShould quad converge (icheck=0) then qsuba will return the value obtained by it; otherwise subdivision will be invoked as a rescue operation in an adaptive manner. The argument relerr gives a crude estimate of the actual relative error obtained. The subdivision strategy is as follows: at each stage of the process, an interval is presented for subdivision. (Initially this will be the whole interval (a,b)). The interval is halved and quad applied to each subinterval. Should quad fail on the first subinterval, the subinterval is stacked for future subdivision and the second subinterval immediately examined. Should quad fail on the second subinterval, the subinterval is immediately subdivided and the whole process repeated. Each time a converged result is obtained, it is accumulated as the partial value of the integral. When quad converges on both subintervals, the interval last stacked is chosen next for subdivision and the process repeated. A subinterval is not examined again once a converged result is obtained for it, so that a spurious convergence is more likely to slip through than for the non-adaptive algorithm qsub. The convergence criterion of quad is slightly relaxed in that a panel is deemed to have been successfully integrated if either quad converges or the estimated absolute error committed on this panel does not exceed epsil times the estimated absolute value of the integral over (a,b). This relaxation is to try to take account of a common situation where one particular panel causes special difficulty, perhaps due to singularity of some type. In this case, quad could obtain nearly exact answers on all other panels, and so the relative error for the total integration would be almost entirely due to the delinquent panel. Without this condition, the computation might continue despite the requested relative error being achieved. The outcome of the integration is indicated by icheck. icheck = 0 - convergence obtained without invoking subdivision. This would correspond to the direct use of quad. icheck = 1 - result obtained after invoking subdivision. icheck = 2 - as for icheck=1 but at some point the relaxed convergence criterion was used. the risk of underestimating the relative error will be increased. If necessary, confidence may be restored by checking epsil and relerr for a serious discrepancy. icheck negative If during the subdivision process the stack of delinquent intervals becomes full (it is presently set to hold at most 100 numbers) a result is obtained by continuing the integration ignoring convergence failures which cannot be accommodated by the stack. This occurrence is flagged by returning icheck with negative sign. The reliability of the algorithm will decrease for large values of epsil. iI is recommended that epsil should generally be less than about 0.001. Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine quad ( func , a , b , epsil , args = ()) function A Python function or method to integrate. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float Lower limit of integration float Upper limit of integration tuple, optional Extra arguments to pass to func float, optional Relative accuracy required. When the relative difference of two successive formulae does not exceed epsil the last formula computed is taken as the result. array This array, which should be declared to have at least 8 elements, holds the results obtained by the 1, 3, 7, etc. point formulae. The number of formulae computed depends on epsil . integer result[k] holds the value of the integral to the specified relative accuracy. integer Number integrand evaluations. integer On exit normally icheck = 0. However, if convergence to the accuracy requested is not achieved, icheck = 1 on exit. quad This subroutine attempts to calculate the integral of func(x) over the inverval a to b with relative error not exceeding epsil . The result is obtained using a sequence of 1, 3, 7, 15, 31, 63, 127, and 255 point interlacing formulae (no integrand evaluations are wasted) of respective degrees 1, 5, 11, 23, 47, 95, 191 and 383. The formulae are based on the optimal extensions of the 3-point gauss formula. Details of the formulae are given in 'the optimum addition of points to quadrature formulae' by T.N.L. Patterson, Maths. Comp. Vol 22, 847-856, 1968. Parameters Returns Abscissae and weights of quadrature rules are stacked in array `p in the order in which they are needed. Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine","title":"  init  "},{"location":"reference/metagf/__init__/#metagf.intde","text":"Created on Tue Nov 12 14:35:35 2019 @author: U80824876","title":"intde"},{"location":"reference/metagf/__init__/#metagf.intde.intdei","text":"function A Python function or method used to integrate. If G takes many arguments, it is integrated along the axis corresponding to the first argument. double Lower limit of integration double Spatial variable integer Number of integration points in the quadrature rule double Step size parameter, default h = 1.0/32.0 integer Order of transformation nu = 0, 1 tuple, optional Extra arguments to pass to G float Numerical value of the integral G(kro, args) * J_nu(kro * rho) * kro^(nu+1) over the semi-infinite interval kro = (a, infty) intdei(G, a, n, args) This subroutine computes the integral of the following function G(kro, args) * J0(kro * rho) * kro, for nu = 0 G(kro, args) * J1(kro * rho) * kro^2, for nu = 1 over the inverval kro = (a, infty) using double exponential-type quadrature formulas from [1] Golubovic et al. \"Fast Computation of Sommerfeld Integral Tails via Direct Integration Based on Double Exponential-Type Quadrature Formulas,\" IEEE Transactions on Antennas and Propagation, vol. 59, no. 2, February 2011","title":"intdei()"},{"location":"reference/metagf/__init__/#metagf.intde.intdei--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.intde.intdei--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.intde.intdei--rev-date-author-description","text":"v1 12NOV19 Ivica Stevanovic, OFCOM First implementation in python","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.momi","text":"Created on Sat Oct 12 16:09:09 2019 This library of functions implements DE tanh-sinh integration routines and general weighted averages as defined in the following paper: Krzysztof A. Michalski & Juan R. Mosig (2016) Efficient computation of Sommerfeld integral tails \u2013 methods and algorithms, Journal of Electromagnetic Waves and Applications, 30:3, 281-317 https://doi.org/10.1080/09205071.2015.1129915 @author: Ivica Stevanovic (OFCOM)","title":"momi"},{"location":"reference/metagf/__init__/#metagf.momi.MosigMichalski","text":"This function implements the weighted averages method via the Mosig-Michalski algorithm according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 mu: convergence (1 - logarithmic, 2 - otherwise) k: instantaneous transformation order (k = 0,...,kmax) s: kth partial sum omega: ratio of the current and previous remainder estimates at the transformation order k X: an array of dimension k+1: xn = beta + n, beta usually set to 1 R: an array of dimension k+1: containing remainders","title":"MosigMichalski()"},{"location":"reference/metagf/__init__/#metagf.momi.mixedQuad","text":"This function computes the integral of function G over a semi-infinite interval [a, infty) using an automatic mixed quadrature rule according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral eps: square root of the desired precision maxlev: order of the tanh-sinh integration","title":"mixedQuad()"},{"location":"reference/metagf/__init__/#metagf.momi.omega","text":"This function computes the ratio of the current and previous remainder estimates at the transformation order k in Mosig-Michalski algorithm 7 according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 k: instantaneous transformation order (k = 0,...,kmax) q: equidistant spacing z: source-observer distance in z-direction alpha: 0.5-nu, where nu is the order of Bessel function in the integrand X: equidistant points (in rho)","title":"omega()"},{"location":"reference/metagf/__init__/#metagf.momi.partExtrap","text":"This function computes the integral of function G over a semi-infinite interval [a, infty) using a general partition-extrapolation algorithm via MosigMichalski according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral nu: order of Bessel function in the integrand eps: square root of the desired precision kmax: max order of the general WA algorithm maxlev: max level in DE tanh-sinh numerical integration","title":"partExtrap()"},{"location":"reference/metagf/__init__/#metagf.momi.partSum","text":"Function computing higher level partial sum according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated eh: exponent of h (initial mesh size) e2h: exponent of 2h (initial mesh size) eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval","title":"partSum()"},{"location":"reference/metagf/__init__/#metagf.momi.tanhSinhQuad","text":"This function computes the integral of function G over a bounded interval [a, b] using an automatic tanh-sinh quadrature rule according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral b: upper limit of the bounded integral eps: square root of the desired precision maxlev: order of the tanh-sinh integration Function G(kro) should be programmed as a two-parameter procedure G(c, d), where kro = c + d, c = a or b, and d = \u00b1\u03c3 \u03b4 , so that the singular part may be computed using d directly. For example, if the integrand comprises a term (kro\u2212a)^(-alpha) (b-kro)^(-beta) with alpha > 0 and beta > 0, this procedure should compute it as compute it as d^(-alpha) * (b-kro)^(-beta) when d > 0 and as (kro - a)^(-alpha) * (-d)^(-beta) when d < 0","title":"tanhSinhQuad()"},{"location":"reference/metagf/__init__/#metagf.momi.term","text":"kth term of quadrature rule according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated ekh: exponent of the kth term exp(kh) eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval","title":"term()"},{"location":"reference/metagf/__init__/#metagf.momi.truncIndex","text":"Function computing an initial truncation index and partial sum according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated eh: exponent of h (initial mesh size) s: initial value of the partial sum eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval nmax: maximum number of points in the term quadrature rule kappa: truncation error","title":"truncIndex()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld","text":"","title":"sommerfeld"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.gauleg","text":"gauleg: Gauss-Legendre n-point quadrature w, x = gauleg(n, a1, a2) where: Units, Definition Limits n: - Number of integration points >1 a1: - Lower limit of the integration a2: - Upper limit of the integration w: - Vector of weights x: - Vector of abscissae This subroutine computes the weights and abcissae for a Gauss- Legendre n-point quadrature formula. The program computes the n-roots of the Legendre polynomial of order n. It uses a Newton method to find numerically the zeros.","title":"gauleg()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.gauleg--rev-date-author-description","text":"v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.halfsine","text":"function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float width of the half-sine contour float maximum height of the half-sine contour integer number of integration points tuple, optional Extra arguments to pass to func float The value of the integral half_sine: computes the integral of the function func(x,args) over a half-sine contour defined by the widht a and height c using Gauss-Legendre quadrature with required number of integration points nints y = half_sine(func, a, c, nints, args)","title":"halfsine()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.halfsine--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.halfsine--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.halfsine--rev-date-author-description","text":"v1 14NOV19 Ivica Stevanovic, OFCOM First implementation","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.intt2_s0","text":"computes the integral of the following function J0(x r) x*G(x) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) integer Number of points in Gauss-Legendre integration float Lower integration limit float Upper integration limit tuple, optional Extra arguments to pass to G float The value of integral in the zero order Sommerfeld transformation over a bounded interval (a, b) in the bounded interval (a,b), where G(x, args) is spectral domain function and J0(x) is Bessel function of zero order and first kind y = intt2_s0(G, rn, nt, a, b, args)","title":"intt2_s0()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.intt2_s0--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.intt2_s0--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.intt2_s0--rev-date-author-description","text":"v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.intt2_s1","text":"computes the integral of the following function J1(x r) x^2 G(x, args) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) integer Number of points in Gauss-Legendre integration float Lower integration limit float Upper integration limit tuple, optional Extra arguments to pass to G float The value of integral in the zero order Sommerfeld transformation over a bounded interval (a, b) in the bounded interval (a,b), where G(x,*args) is spectral domain function and J1(x) is Bessel function of first order and first kind y = intt2_s1(G, arg, rn, nt, a, b)","title":"intt2_s1()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.intt2_s1--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.intt2_s1--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.intt2_s1--rev-date-author-description","text":"v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it1_s0","text":"function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Smaller semi-axis of the elliptic path float Larger axis of the elliptic path float Number of integration points tuple, optional Extra arguments to pass to G float The value of integral T1 (0,b1) in the zero order Sommerfeld transformation along the elliptic contour it1_s0: computes the integral T1 (0,b1) for the evaluation of zero order Sommerfeld transformation. The integral is computed following an elliptic contour path y = it1_s0(G, rn, b1, b2, nt1, args)","title":"it1_s0()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it1_s0--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it1_s0--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it1_s0--rev-date-author-description","text":"v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it1_s1","text":"function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Smaller semi-axis of the elliptic path float Larger axis of the elliptic path float Number of integration points tuple, optional Extra arguments to pass to G float The value of integral T1 (0,b1) in the first order Sommerfeld transformation along the elliptic contour it1_s1: computes the integral T1 (0,b1) for the evaluation of first order Sommerfeld transformation. The integral is computed following an elliptic contour path y = it1_s1(G, rn, b1, b2, nt1)","title":"it1_s1()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it1_s1--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it1_s1--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it1_s1--rev-date-author-description","text":"v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it2_s0","text":"computes the integral T2 (b2-infty) for the evaluation of zero order Sommerfeld transformation The integral is computed using the weighted averages method function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Starting point of the integration path (corresponds to the larger ellipse axis) integer Number of integration points per segment complex Value of the integral along the ellipse integer cs = 1 when source and obesrver are at the same z-coordinate float Required precision in the WA algorithm integer Maximum number of iterations tuple, optional Extra arguments to pass to G float The value of integral T2 (b2, infty) in the zero order Sommerfeld transformation using weigthed averages y = it2_s0(G, arg, rn, b2, nt2, y1, cs, prec)","title":"it2_s0()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it2_s0--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it2_s0--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it2_s0--rev-date-author-description","text":"v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it2_s1","text":"computes the integral T2 (b2-infty) for the evaluation of first order Sommerfeld transformation The integral is computed using the weighted averages method function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Starting point of the integration path (corresponds to the larger ellipse axis) integer Number of integration points per segment complex Value of the integral along the ellipse integer cs = 1 when source and obesrver are at the same z-coordinate float Required precision in the WA algorithm integer Maximum number of iterations tuple, optional Extra arguments to pass to G float The value of integral T2 (b2, infty) in the first order Sommerfeld transformation using weigthed averages y = it2_s1(G, rn, b2, nt2, y1, cs, prec)","title":"it2_s1()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it2_s1--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it2_s1--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.it2_s1--rev-date-author-description","text":"v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.quad","text":"function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float lower limit of the integration interval float upper limit of the integration interval integer number of integration points tuple, optional Extra arguments to pass to func float The value of the integral quad: computes the integral of the function func(x,args) over real-axis x using Gauss-Legendre quadrature with required number of integration points nints over interval (a,b) y = quad(func, a, b, nints, args)","title":"quad()"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.quad--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.quad--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.sommerfeld.quad--rev-date-author-description","text":"v1 14NOV19 Ivica Stevanovic, OFCOM First implementation","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.toms468","text":"","title":"toms468"},{"location":"reference/metagf/__init__/#metagf.toms468.halfsine","text":"function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float width of the half-sine contour float maximum height of the half-sine contour float required precision in Patterson quadrature tuple, optional Extra arguments to pass to func float The value of the integral integer Number integrand evaluations. float The projected relative error achieved by Patterson quadrature integer On exit normally icheck = 0. However, if convergence to the accuracy requested is not achieved, icheck = 1 on exit. half_sine: computes the integral of the function func(x,args) over a half-sine contour defined by the widht a and height c using Patterson quadrature with required precision epsil y, npts, relerr, icheck = half_sine(func, a, c, epsil, args)","title":"halfsine()"},{"location":"reference/metagf/__init__/#metagf.toms468.halfsine--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.toms468.halfsine--returns","text":"","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.toms468.halfsine--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.toms468.isign","text":"Function isign(a, b) returns the value of a with the sign of b.","title":"isign()"},{"location":"reference/metagf/__init__/#metagf.toms468.isign--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.toms468.qsub","text":"qsub This function routine performs automatic integration over a finite interval using the basic integration algorithm quad, together with, if necessary, a non- adaptive subdivision process. The call takes the form qqsub, npts, relerr, icheck = qsub(f, a, b epsil, args) and causes f(x,args) to be integrated over x in (a,b) with relative error hopefully not exceeding epsil. Should quad converge (icheck=0) then qsub will return the value obtained by it; otherwise subdivision will be invoked as a rescue operation in a non-adaptive manner. The argument relerr gives a crude estimate of the actual relative error obtained. The subdivision strategy is as follows: Let the interval (a,b) be divided into 2**n panels at step n of the subdivision process. quad is applied first to the subdivided interval on which quad last failed to converge, and if convergence is now achieved the remaining panels are integrated. should a convergence failure occur on any panel, the integration at that point is terminated and the procedure repeated with n increased by 1. The strategy ensures that possibly delinquent intervals are examined before work, which later might have to be discarded, is invested in well-behaved panels. The process is complete when no convergence failure occurs on any panel and the sum of the results obtained by quad on each panel is taken as the value of the integral. The process is very cautious in that the subdivision of the interval (a,b) is uniform, the fineness of which is controlled by the success of quad. In this way, it is rather difficult for a spurious convergence to slip through. The convergence criterion of quad is slightly relaxed in that a panel is deemed to have been successfully integrated if either quad converges or the estimated absolute error committed on this panel does not exceed epsil times the estimated absolute value of the integral over (a,b). This relaxation is to try to take account of a common situation where one particular panel causes special difficulty, perhaps due to singularity of some type. In this case, quad could obtain nearly exact answers on all other panels, and so the relative error for the total integration would be almost entirely due to the delinquent panel. Without this condition, the computation might continue despite the requested relative error being achieved. The outcome of the integration is indicated by icheck. icheck = 0 - convergence obtained without invoking subdivision. This corresponds to the direct use of quad. icheck = 1 - result obtained after invoking subdivision. icheck = 2 - as for icheck=1 but at some point the relaxed convergence criterion was used. the risk of underestimating the relative error will be increased. If necessary, confidence may be restored by checking epsil and relerr for a serious discrepancy. icheck negative if during the subdivision process the allowed upper limit on the number of panels that may be generated (presently 4096) is reached, a result is obtained which may be unreliable by continuing the integration without further subdivision ignoring convergence failures. This occurrence is flagged by returning icheck with negative sign. The reliability of the algorithm will decrease for large values of epsil. It is recommended that epsil should generally be less than about 0.001.","title":"qsub()"},{"location":"reference/metagf/__init__/#metagf.toms468.qsub--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.toms468.qsuba","text":"qsuba This function routine performs automatic integration over a finite interval using the basic integration algorithm quad, together with, if necessary, an adaptive subdivision process. It is generally more efficient than the non-adaptive algorithm qsub but is likely to be less reliable (see Comp.J., 14, 189, 1971 ). The call takes the form result, npts, relerr, icheck = qsuba(f, a, b, epsil, arg) and causes f(x, arg) to be integrated over x in (a,b) with relative error hopefully not exceeding epsil. sShould quad converge (icheck=0) then qsuba will return the value obtained by it; otherwise subdivision will be invoked as a rescue operation in an adaptive manner. The argument relerr gives a crude estimate of the actual relative error obtained. The subdivision strategy is as follows: at each stage of the process, an interval is presented for subdivision. (Initially this will be the whole interval (a,b)). The interval is halved and quad applied to each subinterval. Should quad fail on the first subinterval, the subinterval is stacked for future subdivision and the second subinterval immediately examined. Should quad fail on the second subinterval, the subinterval is immediately subdivided and the whole process repeated. Each time a converged result is obtained, it is accumulated as the partial value of the integral. When quad converges on both subintervals, the interval last stacked is chosen next for subdivision and the process repeated. A subinterval is not examined again once a converged result is obtained for it, so that a spurious convergence is more likely to slip through than for the non-adaptive algorithm qsub. The convergence criterion of quad is slightly relaxed in that a panel is deemed to have been successfully integrated if either quad converges or the estimated absolute error committed on this panel does not exceed epsil times the estimated absolute value of the integral over (a,b). This relaxation is to try to take account of a common situation where one particular panel causes special difficulty, perhaps due to singularity of some type. In this case, quad could obtain nearly exact answers on all other panels, and so the relative error for the total integration would be almost entirely due to the delinquent panel. Without this condition, the computation might continue despite the requested relative error being achieved. The outcome of the integration is indicated by icheck. icheck = 0 - convergence obtained without invoking subdivision. This would correspond to the direct use of quad. icheck = 1 - result obtained after invoking subdivision. icheck = 2 - as for icheck=1 but at some point the relaxed convergence criterion was used. the risk of underestimating the relative error will be increased. If necessary, confidence may be restored by checking epsil and relerr for a serious discrepancy. icheck negative If during the subdivision process the stack of delinquent intervals becomes full (it is presently set to hold at most 100 numbers) a result is obtained by continuing the integration ignoring convergence failures which cannot be accommodated by the stack. This occurrence is flagged by returning icheck with negative sign. The reliability of the algorithm will decrease for large values of epsil. iI is recommended that epsil should generally be less than about 0.001.","title":"qsuba()"},{"location":"reference/metagf/__init__/#metagf.toms468.qsuba--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/__init__/#metagf.toms468.quad","text":"function A Python function or method to integrate. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float Lower limit of integration float Upper limit of integration tuple, optional Extra arguments to pass to func float, optional Relative accuracy required. When the relative difference of two successive formulae does not exceed epsil the last formula computed is taken as the result. array This array, which should be declared to have at least 8 elements, holds the results obtained by the 1, 3, 7, etc. point formulae. The number of formulae computed depends on epsil . integer result[k] holds the value of the integral to the specified relative accuracy. integer Number integrand evaluations. integer On exit normally icheck = 0. However, if convergence to the accuracy requested is not achieved, icheck = 1 on exit. quad This subroutine attempts to calculate the integral of func(x) over the inverval a to b with relative error not exceeding epsil . The result is obtained using a sequence of 1, 3, 7, 15, 31, 63, 127, and 255 point interlacing formulae (no integrand evaluations are wasted) of respective degrees 1, 5, 11, 23, 47, 95, 191 and 383. The formulae are based on the optimal extensions of the 3-point gauss formula. Details of the formulae are given in 'the optimum addition of points to quadrature formulae' by T.N.L. Patterson, Maths. Comp. Vol 22, 847-856, 1968.","title":"quad()"},{"location":"reference/metagf/__init__/#metagf.toms468.quad--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/__init__/#metagf.toms468.quad--returns","text":"Abscissae and weights of quadrature rules are stacked in array `p in the order in which they are needed.","title":"Returns"},{"location":"reference/metagf/__init__/#metagf.toms468.quad--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/intde/","text":"Created on Tue Nov 12 14:35:35 2019 @author: U80824876 intdei ( G , a , rho , n , h , nu , args = ()) function A Python function or method used to integrate. If G takes many arguments, it is integrated along the axis corresponding to the first argument. double Lower limit of integration double Spatial variable integer Number of integration points in the quadrature rule double Step size parameter, default h = 1.0/32.0 integer Order of transformation nu = 0, 1 tuple, optional Extra arguments to pass to G float Numerical value of the integral G(kro, args) * J_nu(kro * rho) * kro^(nu+1) over the semi-infinite interval kro = (a, infty) intdei(G, a, n, args) This subroutine computes the integral of the following function G(kro, args) * J0(kro * rho) * kro, for nu = 0 G(kro, args) * J1(kro * rho) * kro^2, for nu = 1 over the inverval kro = (a, infty) using double exponential-type quadrature formulas from [1] Golubovic et al. \"Fast Computation of Sommerfeld Integral Tails via Direct Integration Based on Double Exponential-Type Quadrature Formulas,\" IEEE Transactions on Antennas and Propagation, vol. 59, no. 2, February 2011 Parameters Returns Rev Date Author Description v1 12NOV19 Ivica Stevanovic, OFCOM First implementation in python","title":"Intde"},{"location":"reference/metagf/intde/#metagf.intde.intdei","text":"function A Python function or method used to integrate. If G takes many arguments, it is integrated along the axis corresponding to the first argument. double Lower limit of integration double Spatial variable integer Number of integration points in the quadrature rule double Step size parameter, default h = 1.0/32.0 integer Order of transformation nu = 0, 1 tuple, optional Extra arguments to pass to G float Numerical value of the integral G(kro, args) * J_nu(kro * rho) * kro^(nu+1) over the semi-infinite interval kro = (a, infty) intdei(G, a, n, args) This subroutine computes the integral of the following function G(kro, args) * J0(kro * rho) * kro, for nu = 0 G(kro, args) * J1(kro * rho) * kro^2, for nu = 1 over the inverval kro = (a, infty) using double exponential-type quadrature formulas from [1] Golubovic et al. \"Fast Computation of Sommerfeld Integral Tails via Direct Integration Based on Double Exponential-Type Quadrature Formulas,\" IEEE Transactions on Antennas and Propagation, vol. 59, no. 2, February 2011","title":"intdei()"},{"location":"reference/metagf/intde/#metagf.intde.intdei--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/intde/#metagf.intde.intdei--returns","text":"","title":"Returns"},{"location":"reference/metagf/intde/#metagf.intde.intdei--rev-date-author-description","text":"v1 12NOV19 Ivica Stevanovic, OFCOM First implementation in python","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/momi/","text":"Created on Sat Oct 12 16:09:09 2019 This library of functions implements DE tanh-sinh integration routines and general weighted averages as defined in the following paper: Krzysztof A. Michalski & Juan R. Mosig (2016) Efficient computation of Sommerfeld integral tails \u2013 methods and algorithms, Journal of Electromagnetic Waves and Applications, 30:3, 281-317 https://doi.org/10.1080/09205071.2015.1129915 @author: Ivica Stevanovic (OFCOM) MosigMichalski ( mu , k , s , omega , X , R ) This function implements the weighted averages method via the Mosig-Michalski algorithm according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 mu: convergence (1 - logarithmic, 2 - otherwise) k: instantaneous transformation order (k = 0,...,kmax) s: kth partial sum omega: ratio of the current and previous remainder estimates at the transformation order k X: an array of dimension k+1: xn = beta + n, beta usually set to 1 R: an array of dimension k+1: containing remainders mixedQuad ( G , args , a , eps , maxlev ) This function computes the integral of function G over a semi-infinite interval [a, infty) using an automatic mixed quadrature rule according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral eps: square root of the desired precision maxlev: order of the tanh-sinh integration omega ( k , q , z , alpha , X ) This function computes the ratio of the current and previous remainder estimates at the transformation order k in Mosig-Michalski algorithm 7 according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 k: instantaneous transformation order (k = 0,...,kmax) q: equidistant spacing z: source-observer distance in z-direction alpha: 0.5-nu, where nu is the order of Bessel function in the integrand X: equidistant points (in rho) partExtrap ( G , rho , z , a , nu , eps , kmax , maxlev , args ) This function computes the integral of function G over a semi-infinite interval [a, infty) using a general partition-extrapolation algorithm via MosigMichalski according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral nu: order of Bessel function in the integrand eps: square root of the desired precision kmax: max order of the general WA algorithm maxlev: max level in DE tanh-sinh numerical integration partSum ( G , args , eh , e2h , n , eta , sigma , a , b ) Function computing higher level partial sum according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated eh: exponent of h (initial mesh size) e2h: exponent of 2h (initial mesh size) eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval tanhSinhQuad ( G , args , a , b , eps , maxlev ) This function computes the integral of function G over a bounded interval [a, b] using an automatic tanh-sinh quadrature rule according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral b: upper limit of the bounded integral eps: square root of the desired precision maxlev: order of the tanh-sinh integration Function G(kro) should be programmed as a two-parameter procedure G(c, d), where kro = c + d, c = a or b, and d = \u00b1\u03c3 \u03b4 , so that the singular part may be computed using d directly. For example, if the integrand comprises a term (kro\u2212a)^(-alpha) (b-kro)^(-beta) with alpha > 0 and beta > 0, this procedure should compute it as compute it as d^(-alpha) * (b-kro)^(-beta) when d > 0 and as (kro - a)^(-alpha) * (-d)^(-beta) when d < 0 term ( G , args , ekh , eta , sigma , a , b ) kth term of quadrature rule according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated ekh: exponent of the kth term exp(kh) eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval truncIndex ( G , args , eh , s , eta , sigma , a , b , nmax , kappa ) Function computing an initial truncation index and partial sum according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated eh: exponent of h (initial mesh size) s: initial value of the partial sum eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval nmax: maximum number of points in the term quadrature rule kappa: truncation error","title":"Momi"},{"location":"reference/metagf/momi/#metagf.momi.MosigMichalski","text":"This function implements the weighted averages method via the Mosig-Michalski algorithm according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 mu: convergence (1 - logarithmic, 2 - otherwise) k: instantaneous transformation order (k = 0,...,kmax) s: kth partial sum omega: ratio of the current and previous remainder estimates at the transformation order k X: an array of dimension k+1: xn = beta + n, beta usually set to 1 R: an array of dimension k+1: containing remainders","title":"MosigMichalski()"},{"location":"reference/metagf/momi/#metagf.momi.mixedQuad","text":"This function computes the integral of function G over a semi-infinite interval [a, infty) using an automatic mixed quadrature rule according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral eps: square root of the desired precision maxlev: order of the tanh-sinh integration","title":"mixedQuad()"},{"location":"reference/metagf/momi/#metagf.momi.omega","text":"This function computes the ratio of the current and previous remainder estimates at the transformation order k in Mosig-Michalski algorithm 7 according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 k: instantaneous transformation order (k = 0,...,kmax) q: equidistant spacing z: source-observer distance in z-direction alpha: 0.5-nu, where nu is the order of Bessel function in the integrand X: equidistant points (in rho)","title":"omega()"},{"location":"reference/metagf/momi/#metagf.momi.partExtrap","text":"This function computes the integral of function G over a semi-infinite interval [a, infty) using a general partition-extrapolation algorithm via MosigMichalski according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral nu: order of Bessel function in the integrand eps: square root of the desired precision kmax: max order of the general WA algorithm maxlev: max level in DE tanh-sinh numerical integration","title":"partExtrap()"},{"location":"reference/metagf/momi/#metagf.momi.partSum","text":"Function computing higher level partial sum according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated eh: exponent of h (initial mesh size) e2h: exponent of 2h (initial mesh size) eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval","title":"partSum()"},{"location":"reference/metagf/momi/#metagf.momi.tanhSinhQuad","text":"This function computes the integral of function G over a bounded interval [a, b] using an automatic tanh-sinh quadrature rule according to Michalski&Mosig's paper in https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated a: lower limit of the bounded integral b: upper limit of the bounded integral eps: square root of the desired precision maxlev: order of the tanh-sinh integration Function G(kro) should be programmed as a two-parameter procedure G(c, d), where kro = c + d, c = a or b, and d = \u00b1\u03c3 \u03b4 , so that the singular part may be computed using d directly. For example, if the integrand comprises a term (kro\u2212a)^(-alpha) (b-kro)^(-beta) with alpha > 0 and beta > 0, this procedure should compute it as compute it as d^(-alpha) * (b-kro)^(-beta) when d > 0 and as (kro - a)^(-alpha) * (-d)^(-beta) when d < 0","title":"tanhSinhQuad()"},{"location":"reference/metagf/momi/#metagf.momi.term","text":"kth term of quadrature rule according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated ekh: exponent of the kth term exp(kh) eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval","title":"term()"},{"location":"reference/metagf/momi/#metagf.momi.truncIndex","text":"Function computing an initial truncation index and partial sum according to Michalski&Mosig's automatic tanh-sinh quadrature https://doi.org/10.1080/09205071.2015.1129915 G: function to be integrated eh: exponent of h (initial mesh size) s: initial value of the partial sum eta: positive parameter close to unity sigma: half of the integration interval a: lower limit of the bounded integration interval b: upper limit of the bounded integration interval nmax: maximum number of points in the term quadrature rule kappa: truncation error","title":"truncIndex()"},{"location":"reference/metagf/sommerfeld/","text":"gauleg ( n , a1 , a2 ) gauleg: Gauss-Legendre n-point quadrature w, x = gauleg(n, a1, a2) where: Units, Definition Limits n: - Number of integration points >1 a1: - Lower limit of the integration a2: - Upper limit of the integration w: - Vector of weights x: - Vector of abscissae This subroutine computes the weights and abcissae for a Gauss- Legendre n-point quadrature formula. The program computes the n-roots of the Legendre polynomial of order n. It uses a Newton method to find numerically the zeros. Rev Date Author Description v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine halfsine ( func , a , c , nints , args ) function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float width of the half-sine contour float maximum height of the half-sine contour integer number of integration points tuple, optional Extra arguments to pass to func float The value of the integral half_sine: computes the integral of the function func(x,args) over a half-sine contour defined by the widht a and height c using Gauss-Legendre quadrature with required number of integration points nints y = half_sine(func, a, c, nints, args) Parameters Returns Rev Date Author Description v1 14NOV19 Ivica Stevanovic, OFCOM First implementation intt2_s0 ( G , rn , nt , a , b , args ) computes the integral of the following function J0(x r) x*G(x) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) integer Number of points in Gauss-Legendre integration float Lower integration limit float Upper integration limit tuple, optional Extra arguments to pass to G float The value of integral in the zero order Sommerfeld transformation over a bounded interval (a, b) in the bounded interval (a,b), where G(x, args) is spectral domain function and J0(x) is Bessel function of zero order and first kind y = intt2_s0(G, rn, nt, a, b, args) Parameters Returns Rev Date Author Description v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine intt2_s1 ( G , rn , nt , a , b , args ) computes the integral of the following function J1(x r) x^2 G(x, args) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) integer Number of points in Gauss-Legendre integration float Lower integration limit float Upper integration limit tuple, optional Extra arguments to pass to G float The value of integral in the zero order Sommerfeld transformation over a bounded interval (a, b) in the bounded interval (a,b), where G(x,*args) is spectral domain function and J1(x) is Bessel function of first order and first kind y = intt2_s1(G, arg, rn, nt, a, b) Parameters Returns Rev Date Author Description v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python it1_s0 ( G , rn , b1 , b2 , nt1 , args ) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Smaller semi-axis of the elliptic path float Larger axis of the elliptic path float Number of integration points tuple, optional Extra arguments to pass to G float The value of integral T1 (0,b1) in the zero order Sommerfeld transformation along the elliptic contour it1_s0: computes the integral T1 (0,b1) for the evaluation of zero order Sommerfeld transformation. The integral is computed following an elliptic contour path y = it1_s0(G, rn, b1, b2, nt1, args) Parameters Returns Rev Date Author Description v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine it1_s1 ( G , rn , b1 , b2 , nt1 , args ) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Smaller semi-axis of the elliptic path float Larger axis of the elliptic path float Number of integration points tuple, optional Extra arguments to pass to G float The value of integral T1 (0,b1) in the first order Sommerfeld transformation along the elliptic contour it1_s1: computes the integral T1 (0,b1) for the evaluation of first order Sommerfeld transformation. The integral is computed following an elliptic contour path y = it1_s1(G, rn, b1, b2, nt1) Parameters Returns Rev Date Author Description v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine it2_s0 ( G , rn , b2 , nt2 , y1 , cs , prec , nit , args ) computes the integral T2 (b2-infty) for the evaluation of zero order Sommerfeld transformation The integral is computed using the weighted averages method function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Starting point of the integration path (corresponds to the larger ellipse axis) integer Number of integration points per segment complex Value of the integral along the ellipse integer cs = 1 when source and obesrver are at the same z-coordinate float Required precision in the WA algorithm integer Maximum number of iterations tuple, optional Extra arguments to pass to G float The value of integral T2 (b2, infty) in the zero order Sommerfeld transformation using weigthed averages y = it2_s0(G, arg, rn, b2, nt2, y1, cs, prec) Parameters Returns Rev Date Author Description v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine it2_s1 ( G , rn , b2 , nt2 , y1 , cs , prec , nit , args ) computes the integral T2 (b2-infty) for the evaluation of first order Sommerfeld transformation The integral is computed using the weighted averages method function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Starting point of the integration path (corresponds to the larger ellipse axis) integer Number of integration points per segment complex Value of the integral along the ellipse integer cs = 1 when source and obesrver are at the same z-coordinate float Required precision in the WA algorithm integer Maximum number of iterations tuple, optional Extra arguments to pass to G float The value of integral T2 (b2, infty) in the first order Sommerfeld transformation using weigthed averages y = it2_s1(G, rn, b2, nt2, y1, cs, prec) Parameters Returns Rev Date Author Description v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine quad ( func , a , b , nints , args ) function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float lower limit of the integration interval float upper limit of the integration interval integer number of integration points tuple, optional Extra arguments to pass to func float The value of the integral quad: computes the integral of the function func(x,args) over real-axis x using Gauss-Legendre quadrature with required number of integration points nints over interval (a,b) y = quad(func, a, b, nints, args) Parameters Returns Rev Date Author Description v1 14NOV19 Ivica Stevanovic, OFCOM First implementation","title":"Sommerfeld"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.gauleg","text":"gauleg: Gauss-Legendre n-point quadrature w, x = gauleg(n, a1, a2) where: Units, Definition Limits n: - Number of integration points >1 a1: - Lower limit of the integration a2: - Upper limit of the integration w: - Vector of weights x: - Vector of abscissae This subroutine computes the weights and abcissae for a Gauss- Legendre n-point quadrature formula. The program computes the n-roots of the Legendre polynomial of order n. It uses a Newton method to find numerically the zeros.","title":"gauleg()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.gauleg--rev-date-author-description","text":"v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.halfsine","text":"function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float width of the half-sine contour float maximum height of the half-sine contour integer number of integration points tuple, optional Extra arguments to pass to func float The value of the integral half_sine: computes the integral of the function func(x,args) over a half-sine contour defined by the widht a and height c using Gauss-Legendre quadrature with required number of integration points nints y = half_sine(func, a, c, nints, args)","title":"halfsine()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.halfsine--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.halfsine--returns","text":"","title":"Returns"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.halfsine--rev-date-author-description","text":"v1 14NOV19 Ivica Stevanovic, OFCOM First implementation","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.intt2_s0","text":"computes the integral of the following function J0(x r) x*G(x) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) integer Number of points in Gauss-Legendre integration float Lower integration limit float Upper integration limit tuple, optional Extra arguments to pass to G float The value of integral in the zero order Sommerfeld transformation over a bounded interval (a, b) in the bounded interval (a,b), where G(x, args) is spectral domain function and J0(x) is Bessel function of zero order and first kind y = intt2_s0(G, rn, nt, a, b, args)","title":"intt2_s0()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.intt2_s0--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.intt2_s0--returns","text":"","title":"Returns"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.intt2_s0--rev-date-author-description","text":"v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.intt2_s1","text":"computes the integral of the following function J1(x r) x^2 G(x, args) function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) integer Number of points in Gauss-Legendre integration float Lower integration limit float Upper integration limit tuple, optional Extra arguments to pass to G float The value of integral in the zero order Sommerfeld transformation over a bounded interval (a, b) in the bounded interval (a,b), where G(x,*args) is spectral domain function and J1(x) is Bessel function of first order and first kind y = intt2_s1(G, arg, rn, nt, a, b)","title":"intt2_s1()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.intt2_s1--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.intt2_s1--returns","text":"","title":"Returns"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.intt2_s1--rev-date-author-description","text":"v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it1_s0","text":"function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Smaller semi-axis of the elliptic path float Larger axis of the elliptic path float Number of integration points tuple, optional Extra arguments to pass to G float The value of integral T1 (0,b1) in the zero order Sommerfeld transformation along the elliptic contour it1_s0: computes the integral T1 (0,b1) for the evaluation of zero order Sommerfeld transformation. The integral is computed following an elliptic contour path y = it1_s0(G, rn, b1, b2, nt1, args)","title":"it1_s0()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it1_s0--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it1_s0--returns","text":"","title":"Returns"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it1_s0--rev-date-author-description","text":"v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it1_s1","text":"function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Smaller semi-axis of the elliptic path float Larger axis of the elliptic path float Number of integration points tuple, optional Extra arguments to pass to G float The value of integral T1 (0,b1) in the first order Sommerfeld transformation along the elliptic contour it1_s1: computes the integral T1 (0,b1) for the evaluation of first order Sommerfeld transformation. The integral is computed following an elliptic contour path y = it1_s1(G, rn, b1, b2, nt1)","title":"it1_s1()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it1_s1--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it1_s1--returns","text":"","title":"Returns"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it1_s1--rev-date-author-description","text":"v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it2_s0","text":"computes the integral T2 (b2-infty) for the evaluation of zero order Sommerfeld transformation The integral is computed using the weighted averages method function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Starting point of the integration path (corresponds to the larger ellipse axis) integer Number of integration points per segment complex Value of the integral along the ellipse integer cs = 1 when source and obesrver are at the same z-coordinate float Required precision in the WA algorithm integer Maximum number of iterations tuple, optional Extra arguments to pass to G float The value of integral T2 (b2, infty) in the zero order Sommerfeld transformation using weigthed averages y = it2_s0(G, arg, rn, b2, nt2, y1, cs, prec)","title":"it2_s0()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it2_s0--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it2_s0--returns","text":"","title":"Returns"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it2_s0--rev-date-author-description","text":"v1 03OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it2_s1","text":"computes the integral T2 (b2-infty) for the evaluation of first order Sommerfeld transformation The integral is computed using the weighted averages method function Spectral domain function G(kro, *args) float Normalized spatial variable (rn = k0*r) float Starting point of the integration path (corresponds to the larger ellipse axis) integer Number of integration points per segment complex Value of the integral along the ellipse integer cs = 1 when source and obesrver are at the same z-coordinate float Required precision in the WA algorithm integer Maximum number of iterations tuple, optional Extra arguments to pass to G float The value of integral T2 (b2, infty) in the first order Sommerfeld transformation using weigthed averages y = it2_s1(G, rn, b2, nt2, y1, cs, prec)","title":"it2_s1()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it2_s1--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it2_s1--returns","text":"","title":"Returns"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.it2_s1--rev-date-author-description","text":"v1 11OCT19 Ivica Stevanovic, OFCOM First implementation in python from A. A. Melcon Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.quad","text":"function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float lower limit of the integration interval float upper limit of the integration interval integer number of integration points tuple, optional Extra arguments to pass to func float The value of the integral quad: computes the integral of the function func(x,args) over real-axis x using Gauss-Legendre quadrature with required number of integration points nints over interval (a,b) y = quad(func, a, b, nints, args)","title":"quad()"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.quad--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.quad--returns","text":"","title":"Returns"},{"location":"reference/metagf/sommerfeld/#metagf.sommerfeld.quad--rev-date-author-description","text":"v1 14NOV19 Ivica Stevanovic, OFCOM First implementation","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/toms468/","text":"halfsine ( func , a , c , epsil , args ) function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float width of the half-sine contour float maximum height of the half-sine contour float required precision in Patterson quadrature tuple, optional Extra arguments to pass to func float The value of the integral integer Number integrand evaluations. float The projected relative error achieved by Patterson quadrature integer On exit normally icheck = 0. However, if convergence to the accuracy requested is not achieved, icheck = 1 on exit. half_sine: computes the integral of the function func(x,args) over a half-sine contour defined by the widht a and height c using Patterson quadrature with required precision epsil y, npts, relerr, icheck = half_sine(func, a, c, epsil, args) Parameters Returns Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation isign ( a , b ) Function isign(a, b) returns the value of a with the sign of b. Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python qsub ( f , a , b , epsil , args = ()) qsub This function routine performs automatic integration over a finite interval using the basic integration algorithm quad, together with, if necessary, a non- adaptive subdivision process. The call takes the form qqsub, npts, relerr, icheck = qsub(f, a, b epsil, args) and causes f(x,args) to be integrated over x in (a,b) with relative error hopefully not exceeding epsil. Should quad converge (icheck=0) then qsub will return the value obtained by it; otherwise subdivision will be invoked as a rescue operation in a non-adaptive manner. The argument relerr gives a crude estimate of the actual relative error obtained. The subdivision strategy is as follows: Let the interval (a,b) be divided into 2**n panels at step n of the subdivision process. quad is applied first to the subdivided interval on which quad last failed to converge, and if convergence is now achieved the remaining panels are integrated. should a convergence failure occur on any panel, the integration at that point is terminated and the procedure repeated with n increased by 1. The strategy ensures that possibly delinquent intervals are examined before work, which later might have to be discarded, is invested in well-behaved panels. The process is complete when no convergence failure occurs on any panel and the sum of the results obtained by quad on each panel is taken as the value of the integral. The process is very cautious in that the subdivision of the interval (a,b) is uniform, the fineness of which is controlled by the success of quad. In this way, it is rather difficult for a spurious convergence to slip through. The convergence criterion of quad is slightly relaxed in that a panel is deemed to have been successfully integrated if either quad converges or the estimated absolute error committed on this panel does not exceed epsil times the estimated absolute value of the integral over (a,b). This relaxation is to try to take account of a common situation where one particular panel causes special difficulty, perhaps due to singularity of some type. In this case, quad could obtain nearly exact answers on all other panels, and so the relative error for the total integration would be almost entirely due to the delinquent panel. Without this condition, the computation might continue despite the requested relative error being achieved. The outcome of the integration is indicated by icheck. icheck = 0 - convergence obtained without invoking subdivision. This corresponds to the direct use of quad. icheck = 1 - result obtained after invoking subdivision. icheck = 2 - as for icheck=1 but at some point the relaxed convergence criterion was used. the risk of underestimating the relative error will be increased. If necessary, confidence may be restored by checking epsil and relerr for a serious discrepancy. icheck negative if during the subdivision process the allowed upper limit on the number of panels that may be generated (presently 4096) is reached, a result is obtained which may be unreliable by continuing the integration without further subdivision ignoring convergence failures. This occurrence is flagged by returning icheck with negative sign. The reliability of the algorithm will decrease for large values of epsil. It is recommended that epsil should generally be less than about 0.001. Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine qsuba ( f , a , b , epsil , args = ()) qsuba This function routine performs automatic integration over a finite interval using the basic integration algorithm quad, together with, if necessary, an adaptive subdivision process. It is generally more efficient than the non-adaptive algorithm qsub but is likely to be less reliable (see Comp.J., 14, 189, 1971 ). The call takes the form result, npts, relerr, icheck = qsuba(f, a, b, epsil, arg) and causes f(x, arg) to be integrated over x in (a,b) with relative error hopefully not exceeding epsil. sShould quad converge (icheck=0) then qsuba will return the value obtained by it; otherwise subdivision will be invoked as a rescue operation in an adaptive manner. The argument relerr gives a crude estimate of the actual relative error obtained. The subdivision strategy is as follows: at each stage of the process, an interval is presented for subdivision. (Initially this will be the whole interval (a,b)). The interval is halved and quad applied to each subinterval. Should quad fail on the first subinterval, the subinterval is stacked for future subdivision and the second subinterval immediately examined. Should quad fail on the second subinterval, the subinterval is immediately subdivided and the whole process repeated. Each time a converged result is obtained, it is accumulated as the partial value of the integral. When quad converges on both subintervals, the interval last stacked is chosen next for subdivision and the process repeated. A subinterval is not examined again once a converged result is obtained for it, so that a spurious convergence is more likely to slip through than for the non-adaptive algorithm qsub. The convergence criterion of quad is slightly relaxed in that a panel is deemed to have been successfully integrated if either quad converges or the estimated absolute error committed on this panel does not exceed epsil times the estimated absolute value of the integral over (a,b). This relaxation is to try to take account of a common situation where one particular panel causes special difficulty, perhaps due to singularity of some type. In this case, quad could obtain nearly exact answers on all other panels, and so the relative error for the total integration would be almost entirely due to the delinquent panel. Without this condition, the computation might continue despite the requested relative error being achieved. The outcome of the integration is indicated by icheck. icheck = 0 - convergence obtained without invoking subdivision. This would correspond to the direct use of quad. icheck = 1 - result obtained after invoking subdivision. icheck = 2 - as for icheck=1 but at some point the relaxed convergence criterion was used. the risk of underestimating the relative error will be increased. If necessary, confidence may be restored by checking epsil and relerr for a serious discrepancy. icheck negative If during the subdivision process the stack of delinquent intervals becomes full (it is presently set to hold at most 100 numbers) a result is obtained by continuing the integration ignoring convergence failures which cannot be accommodated by the stack. This occurrence is flagged by returning icheck with negative sign. The reliability of the algorithm will decrease for large values of epsil. iI is recommended that epsil should generally be less than about 0.001. Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine quad ( func , a , b , epsil , args = ()) function A Python function or method to integrate. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float Lower limit of integration float Upper limit of integration tuple, optional Extra arguments to pass to func float, optional Relative accuracy required. When the relative difference of two successive formulae does not exceed epsil the last formula computed is taken as the result. array This array, which should be declared to have at least 8 elements, holds the results obtained by the 1, 3, 7, etc. point formulae. The number of formulae computed depends on epsil . integer result[k] holds the value of the integral to the specified relative accuracy. integer Number integrand evaluations. integer On exit normally icheck = 0. However, if convergence to the accuracy requested is not achieved, icheck = 1 on exit. quad This subroutine attempts to calculate the integral of func(x) over the inverval a to b with relative error not exceeding epsil . The result is obtained using a sequence of 1, 3, 7, 15, 31, 63, 127, and 255 point interlacing formulae (no integrand evaluations are wasted) of respective degrees 1, 5, 11, 23, 47, 95, 191 and 383. The formulae are based on the optimal extensions of the 3-point gauss formula. Details of the formulae are given in 'the optimum addition of points to quadrature formulae' by T.N.L. Patterson, Maths. Comp. Vol 22, 847-856, 1968. Parameters Returns Abscissae and weights of quadrature rules are stacked in array `p in the order in which they are needed. Rev Date Author Description v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine","title":"Toms468"},{"location":"reference/metagf/toms468/#metagf.toms468.halfsine","text":"function A Python function or method. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float width of the half-sine contour float maximum height of the half-sine contour float required precision in Patterson quadrature tuple, optional Extra arguments to pass to func float The value of the integral integer Number integrand evaluations. float The projected relative error achieved by Patterson quadrature integer On exit normally icheck = 0. However, if convergence to the accuracy requested is not achieved, icheck = 1 on exit. half_sine: computes the integral of the function func(x,args) over a half-sine contour defined by the widht a and height c using Patterson quadrature with required precision epsil y, npts, relerr, icheck = half_sine(func, a, c, epsil, args)","title":"halfsine()"},{"location":"reference/metagf/toms468/#metagf.toms468.halfsine--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/toms468/#metagf.toms468.halfsine--returns","text":"","title":"Returns"},{"location":"reference/metagf/toms468/#metagf.toms468.halfsine--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/toms468/#metagf.toms468.isign","text":"Function isign(a, b) returns the value of a with the sign of b.","title":"isign()"},{"location":"reference/metagf/toms468/#metagf.toms468.isign--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/toms468/#metagf.toms468.qsub","text":"qsub This function routine performs automatic integration over a finite interval using the basic integration algorithm quad, together with, if necessary, a non- adaptive subdivision process. The call takes the form qqsub, npts, relerr, icheck = qsub(f, a, b epsil, args) and causes f(x,args) to be integrated over x in (a,b) with relative error hopefully not exceeding epsil. Should quad converge (icheck=0) then qsub will return the value obtained by it; otherwise subdivision will be invoked as a rescue operation in a non-adaptive manner. The argument relerr gives a crude estimate of the actual relative error obtained. The subdivision strategy is as follows: Let the interval (a,b) be divided into 2**n panels at step n of the subdivision process. quad is applied first to the subdivided interval on which quad last failed to converge, and if convergence is now achieved the remaining panels are integrated. should a convergence failure occur on any panel, the integration at that point is terminated and the procedure repeated with n increased by 1. The strategy ensures that possibly delinquent intervals are examined before work, which later might have to be discarded, is invested in well-behaved panels. The process is complete when no convergence failure occurs on any panel and the sum of the results obtained by quad on each panel is taken as the value of the integral. The process is very cautious in that the subdivision of the interval (a,b) is uniform, the fineness of which is controlled by the success of quad. In this way, it is rather difficult for a spurious convergence to slip through. The convergence criterion of quad is slightly relaxed in that a panel is deemed to have been successfully integrated if either quad converges or the estimated absolute error committed on this panel does not exceed epsil times the estimated absolute value of the integral over (a,b). This relaxation is to try to take account of a common situation where one particular panel causes special difficulty, perhaps due to singularity of some type. In this case, quad could obtain nearly exact answers on all other panels, and so the relative error for the total integration would be almost entirely due to the delinquent panel. Without this condition, the computation might continue despite the requested relative error being achieved. The outcome of the integration is indicated by icheck. icheck = 0 - convergence obtained without invoking subdivision. This corresponds to the direct use of quad. icheck = 1 - result obtained after invoking subdivision. icheck = 2 - as for icheck=1 but at some point the relaxed convergence criterion was used. the risk of underestimating the relative error will be increased. If necessary, confidence may be restored by checking epsil and relerr for a serious discrepancy. icheck negative if during the subdivision process the allowed upper limit on the number of panels that may be generated (presently 4096) is reached, a result is obtained which may be unreliable by continuing the integration without further subdivision ignoring convergence failures. This occurrence is flagged by returning icheck with negative sign. The reliability of the algorithm will decrease for large values of epsil. It is recommended that epsil should generally be less than about 0.001.","title":"qsub()"},{"location":"reference/metagf/toms468/#metagf.toms468.qsub--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/toms468/#metagf.toms468.qsuba","text":"qsuba This function routine performs automatic integration over a finite interval using the basic integration algorithm quad, together with, if necessary, an adaptive subdivision process. It is generally more efficient than the non-adaptive algorithm qsub but is likely to be less reliable (see Comp.J., 14, 189, 1971 ). The call takes the form result, npts, relerr, icheck = qsuba(f, a, b, epsil, arg) and causes f(x, arg) to be integrated over x in (a,b) with relative error hopefully not exceeding epsil. sShould quad converge (icheck=0) then qsuba will return the value obtained by it; otherwise subdivision will be invoked as a rescue operation in an adaptive manner. The argument relerr gives a crude estimate of the actual relative error obtained. The subdivision strategy is as follows: at each stage of the process, an interval is presented for subdivision. (Initially this will be the whole interval (a,b)). The interval is halved and quad applied to each subinterval. Should quad fail on the first subinterval, the subinterval is stacked for future subdivision and the second subinterval immediately examined. Should quad fail on the second subinterval, the subinterval is immediately subdivided and the whole process repeated. Each time a converged result is obtained, it is accumulated as the partial value of the integral. When quad converges on both subintervals, the interval last stacked is chosen next for subdivision and the process repeated. A subinterval is not examined again once a converged result is obtained for it, so that a spurious convergence is more likely to slip through than for the non-adaptive algorithm qsub. The convergence criterion of quad is slightly relaxed in that a panel is deemed to have been successfully integrated if either quad converges or the estimated absolute error committed on this panel does not exceed epsil times the estimated absolute value of the integral over (a,b). This relaxation is to try to take account of a common situation where one particular panel causes special difficulty, perhaps due to singularity of some type. In this case, quad could obtain nearly exact answers on all other panels, and so the relative error for the total integration would be almost entirely due to the delinquent panel. Without this condition, the computation might continue despite the requested relative error being achieved. The outcome of the integration is indicated by icheck. icheck = 0 - convergence obtained without invoking subdivision. This would correspond to the direct use of quad. icheck = 1 - result obtained after invoking subdivision. icheck = 2 - as for icheck=1 but at some point the relaxed convergence criterion was used. the risk of underestimating the relative error will be increased. If necessary, confidence may be restored by checking epsil and relerr for a serious discrepancy. icheck negative If during the subdivision process the stack of delinquent intervals becomes full (it is presently set to hold at most 100 numbers) a result is obtained by continuing the integration ignoring convergence failures which cannot be accommodated by the stack. This occurrence is flagged by returning icheck with negative sign. The reliability of the algorithm will decrease for large values of epsil. iI is recommended that epsil should generally be less than about 0.001.","title":"qsuba()"},{"location":"reference/metagf/toms468/#metagf.toms468.qsuba--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine","title":"Rev   Date        Author                          Description"},{"location":"reference/metagf/toms468/#metagf.toms468.quad","text":"function A Python function or method to integrate. If func takes many arguments, it is integrated along the axis corresponding to the first argument. float Lower limit of integration float Upper limit of integration tuple, optional Extra arguments to pass to func float, optional Relative accuracy required. When the relative difference of two successive formulae does not exceed epsil the last formula computed is taken as the result. array This array, which should be declared to have at least 8 elements, holds the results obtained by the 1, 3, 7, etc. point formulae. The number of formulae computed depends on epsil . integer result[k] holds the value of the integral to the specified relative accuracy. integer Number integrand evaluations. integer On exit normally icheck = 0. However, if convergence to the accuracy requested is not achieved, icheck = 1 on exit. quad This subroutine attempts to calculate the integral of func(x) over the inverval a to b with relative error not exceeding epsil . The result is obtained using a sequence of 1, 3, 7, 15, 31, 63, 127, and 255 point interlacing formulae (no integrand evaluations are wasted) of respective degrees 1, 5, 11, 23, 47, 95, 191 and 383. The formulae are based on the optimal extensions of the 3-point gauss formula. Details of the formulae are given in 'the optimum addition of points to quadrature formulae' by T.N.L. Patterson, Maths. Comp. Vol 22, 847-856, 1968.","title":"quad()"},{"location":"reference/metagf/toms468/#metagf.toms468.quad--parameters","text":"","title":"Parameters"},{"location":"reference/metagf/toms468/#metagf.toms468.quad--returns","text":"Abscissae and weights of quadrature rules are stacked in array `p in the order in which they are needed.","title":"Returns"},{"location":"reference/metagf/toms468/#metagf.toms468.quad--rev-date-author-description","text":"v1 10NOV19 Ivica Stevanovic, OFCOM First implementation in python translated from toms468 Fortran routine","title":"Rev   Date        Author                          Description"}]}